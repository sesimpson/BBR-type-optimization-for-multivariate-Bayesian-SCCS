#.libPaths("/hpc/scratch/stats/users/ses2155/rpackages/")#
#
#
# multivariate form for sccs likelihood, takes sparse matrix X as input#
#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
	#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
#
		offs_exp_X_par = offs * exp_X_par#
	#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		loglik = as.numeric((t(eta) %*% X_par) - (t(n_pid) %*% log(denom_pid)))#
#
		return( loglik )#
	}#
#
#
# calculate gradient of log likelihood#
#		par = vector of parameters#
#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
#			where r_i = # of risk periods for person i#
# #
	grad <- function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
#
# fisher information where X is the sparse matrix of covariates (drugs), #
# representing a matrix of dimension (total numpds x num drugs)#
#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
#
# choose file folder name based on which combination is being run#
#	filefolder = paste(combo, "/", sep="")#
#
# name of text file (output from perl) that is ready to be fed into R#
#	datafile = "/Users/ses/Desktop/smtest.txt"#
#	datafile = "/Users/ses/Desktop/format_multivar_OUT.txt"#
#	datafile = "/Users/ses/Desktop/format_multivar_OUT_3drugs.txt"#
#	datafile = "/Users/ses/Desktop/format_multivar_OUT_100drugs.txt"#
	datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_12drugs.txt"#
#
#
# data from new format of flat tab-delimited text file, with header#
#	PID	EVT	OFFS	D1	D2	D3	... etc.#
#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
	#names(dat) = c("PID", "EVT", "OFFS", drugcols)#
#
	dat$PID = as.numeric(dat$PID)#
#
#
	# create covariate matrix, stored in sparse format (in "Matrix" package)#
	#
		# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix#
		require(Matrix)#
		i = NULL#
		j = NULL#
		for (d in 1:ndrugs) {#
			this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
			i = c(i, this_row)#
			j = c(j, rep(d, length(this_row)))#
		}#
		X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
		X.sM = as(X.sM, "dgCMatrix")#
#
#
# -------------------- RUN -----------------------------------------------------#
#	cat(	"N\tbeta_hat\tse(beta_hat)\t",#
#			"exp(beta_hat)\tlo95CI_exp(beta_hat)\thi95CI_exp(beta_hat)\n",#
#			sep="" #
#		)#
#
	cat("N = ", length(PIDlist), "\n", sep="") # N#
#
	require(maxLik)#
	#
	cat(date(), "\n")#
	#
	# with gradient, hessian (faster)#
	ML = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start=numeric(ndrugs))#
#
	print(summary(ML))#
	cat("\n")#
	#
	cat(date(), "\n")#
#
	beta_hat = ML$estimate#
	#
	#cat( "\nbeta_hat = ")#
	#print(beta_hat)					# print beta#
#
	info = fisherinfo(beta_hat, X.sM)#
	SE_betahat = sqrt(diag(solve(info)))#
	#cat( "\nSE_betahat = ")#
	#print(SE_betahat)				# print SE beta#
#
	#cat( "\nexp(betahat) =")#
	#print(exp(beta_hat))			# print exp beta#
#
	z_ci = qnorm(0.975)#
	#cat( exp(beta_hat)-z_ci*exp(beta_hat)*SE_betahat, "\t", sep="")     # print loCI#
	#cat( exp(beta_hat)+z_ci*exp(beta_hat)*SE_betahat, "\n", sep="")     # print hiCI#
#
	print( cbind(druglist, beta_hat, SE_betahat))#
	print( cbind(druglist, exp(beta_hat), exp(beta_hat)-z_ci*exp(beta_hat)*SE_betahat, #
		exp(beta_hat)+z_ci*exp(beta_hat)*SE_betahat))#
#
#
	# ------------ MCMC --------------------------------------------------#
	#cat ( "post_mean\tlo95CI_post\thi95CI_post\n", sep="" )#
#
	#b<-rep(0.8,numIter)#
  		#for (i in 2:numIter) {#
  			#b[i] <- runif(1,b[i-1]-0.1,b[i-1]+0.1)#
   			#if (runif(1) > exp(lScalar(b[i])-lScalar(b[i-1])+dnorm(b[i],0,1000,log=TRUE)-#
				#dnorm(b[i-1],0,1000,log=TRUE))) {#
      			#b[i] <- b[i-1]#
  			#}#
		#}#
  		#sort_exp_b <- sort(exp(b))#
  		#cat(mean(sort_exp_b),"\t", sep="")#
  		#cat(sort_exp_b[floor(numIter*0.025)],"\t",sort_exp_b[ceiling(numIter*0.975)],"\n",sep="")
# test BBR-like procedure for SCCS#
#
# functions ---------------------------------------------------------------#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
# RUN: #
	# read in data#
		datafile = #
			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
# loop to do algorithm ---------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 10000#
		lambda = sqrt(2/0.5)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.001) { done = TRUE }				#
		}#
	)	# end system.time
?maxLik
# test BBR-like procedure for SCCS#
#
# functions ---------------------------------------------------------------#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
# RUN: #
	# read in data#
		datafile = #
			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
# loop to do algorithm ---------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 10000#
		lambda = sqrt(2/0.5)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
# compare with ML procedures#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)
beta
ML2$estimate
# test BBR-like procedure for SCCS#
#
# functions ---------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
# RUN: #
	# read in data#
		datafile = #
			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
# loop to do algorithm ---------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "laplace"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
# compare with ML procedures -------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
	system.time(#
	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	)
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
# test BBR-like procedure for SCCS#
#
# functions ---------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
# RUN: #
	# read in data#
		datafile = #
			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
# loop to do algorithm ---------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
# compare with ML procedures -------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
cbind(ML2$estimate, beta)
cbind(ML2$estimate, beta-ML2$estimate)
abs(beta)-abs(ML2$estimate)
# test BBR-like procedure for SCCS#
#
# functions ---------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
# RUN: #
	# read in data#
		datafile = #
			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
# loop to do algorithm ---------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
# compare with ML procedures -------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
# test BBR-like procedure for SCCS#
#
# functions ---------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
# RUN: #
	# read in data#
#		datafile = #
#			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
			#
		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
# loop to do algorithm ---------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
# compare with ML procedures -------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
ML2$estimate
summary(ML2)
# test BBR-like procedure for SCCS#
#
# functions ---------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
# RUN --------------------------------------------------------------------#
	# read in data#
		# from "small_ge" data set, with 30 drugs selected#
#		datafile = #
#			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
			#
		# from "small_osim" data, drugs 1-50 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
		#
		# from "small_osim" data, drugs 1-100 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-100drugs.txt"#
		#
		# from "small_osim" data, 12 drugs selected#
		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
# loop to do algorithm ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
# compare with ML procedures -------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
cbind(ML2$estimate, beta)
druglist
datafile
abs(ML$estimate)-abs(beta)
abs(ML2$estimate)-abs(beta)
		# from "small_osim" data, 12 drugs selected#
		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
#
# loop to do BBR-type procedure ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.00001) { done = TRUE }				#
		}#
	)	# end system.time
dim(dat)
length(PIDlist)
beta
ML2$estimate
abs(ML2$estimate)-abs(beta)
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = 0.00001)
ML2$estimate
abs(ML2$estimate)-abs(beta)
# test BBR-like procedure for SCCS#
#
# functions ------------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
	#
# RUN -------------------------------------------------------------------------#
	# read in data#
		# from "small_ge" data set, with 30 drugs selected#
#		datafile = #
#			"/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
			#
		# from "small_osim" data, drugs 1-50 (ndrugs = )#
	datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
		#
		# from "small_osim" data, drugs 1-100 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-100drugs.txt"#
		#
		# from "small_osim" data, 12 drugs selected#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
#
# loop to do BBR-type procedure ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.00001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
	#
# compare with ML procedures -----------------------------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = 0.00001)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
ML2$estimate
nums = c(721724 , 1112807 , 1118084 , 1328165 , 1341927 , 1112807 , 1118084 , 1328165 , 1341927 , 1341927 , 1537655 , 19009540 , 1341927 , 1537655 , 1734104 , 19009540 , 1141018 , 1341927 , 1537655 , 1734104 , 19009540 , 1141018 , 1341927 , 1537655 , 1734104 , 19009540 , 1141018 , 1545958 , 1734104 , 1141018 , 1545958 , 1734104 , 1545958 , 1537655 , 19009540 , 781039 , 1322184 , 781039 , 1141018 , 1154343 , 1322184 , 781039 , 1107830 , 1141018 , 1154343 , 1322184 , 781039 , 1107830 , 1141018 , 1154343 , 1322184 , 781039 , 1107830 , 1322184 , 781039 , 956874 , 1322184 , 1328165 , 1341927 , 19049105 , 781039 , 956874 , 1322184 , 1328165 , 1341927 , 19049105 , 781039 , 1322184 , 903963 , 975125 , 1107830 , 1112807 , 1341927 , 1518148 , 1545958 , 903963 , 913782 , 929887 , 975125 , 1103006 , 1112807 , 1307046 , 1341927 , 1518148 , 903963 , 913782 , 929887 , 975125 , 1103006 , 1112807 , 1307046 , 1341927 , 1518148 , 1797513 , 903963 , 913782 , 929887 , 975125 , 1103006 , 1112807 , 1307046 , 1341927 , 1518148 , 1797513 , 722031 , 913782 , 929887 , 975125 , 1103006 , 1307046 , 1797513 , 722031 , 913782 , 929887 , 975125 , 1103006 , 1307046 , 1797513 , 722031 , 975125 , 1797513 , 722031 , 975125 , 722031 , 1557272 , 722031 , 1557272 , 1557272 , 781039 , 1516800 , 781039 , 1322184 , 1516800 , 781039 , 1322184 , 1516800 , 1322184 , 1516800 , 1786621 , 956874 , 961047 , 1322184 , 1361711 , 1516800 , 1786621 , 19049105 , 956874 , 961047 , 1322184 , 1361711 , 1516800 , 1786621 , 19049105 , 956874 , 961047 , 1322184 , 1361711 , 1516800 , 19049105 , 956874 , 1322184 , 1328165 , 1361711 , 1516800 , 19049105 , 1154343 , 1322184 , 1328165 , 1361711 , 1516800 , 19049105)
nums
unique(nums)
t(t(unique(nums)))
unique(nums)
nums=c(721724, 1103314, 904501, 1112807, 1557272, 19035704, #
	940864, 1124957, 1125315, 1729720, 740560, 789578,#
	731188, 903963, 918906, 1551099, 1107830, 1154332,#
	941258, 913782, 1537655, 1137529, 1163944, 1237049,#
	725131, 956874, 1118084, 1310149, 1328165, 1501700,#
	904542, 974166, 332418, 1112807, 1341927, 19009540, #
	1734104, 1141018, 1545958, 781039, 1322184, 1154343, 1107830, 956874, 19049105, 903963, 975125, 1518148, 913782, 929887, 1103006, 1307046, 1797513, 722031, 1557272, 1516800, 1786621, 961047, 1361711)
nums
unique(nums)
sort(unique(nums))
length(sort(unique(nums)))
# test BBR-like procedure for SCCS#
#
# functions ------------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
	#
# RUN -------------------------------------------------------------------------#
	# read in data#
		# from "small_ge" data set, with 30 drugs selected#
#		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
		# from "small_ge" data set, with 53 drugs selected#
		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_53drugs.txt"#
			#
		# from "small_osim" data, drugs 1-50 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
		#
		# from "small_osim" data, drugs 1-100 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-100drugs.txt"#
		#
		# from "small_osim" data, 12 drugs selected#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
#
# loop to do BBR-type procedure ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in 1:ndrugs) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.00001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
	#
# compare with ML procedures -----------------------------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = 0.00001)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
beta
ML2$estimate
abs(ML2$estimate) - abs(beta)
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
for(i in sample(1:n)) { print i }
sample(n)
sample(5)
sample(1:5)
# test BBR-like procedure for SCCS#
#
# functions ------------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
	#
# RUN -------------------------------------------------------------------------#
	# read in data#
		# from "small_ge" data set, with 30 drugs selected#
#		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
		# from "small_ge" data set, with 53 drugs selected#
		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_53drugs.txt"#
			#
		# from "small_osim" data, drugs 1-50 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
		#
		# from "small_osim" data, drugs 1-100 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-100drugs.txt"#
		#
		# from "small_osim" data, 12 drugs selected#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
#
# loop to do BBR-type procedure ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in sample(1:ndrugs)) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.00001) { done = TRUE }				#
		}#
	)	# end system.time#
	#
	#
	#
# compare with ML procedures -----------------------------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.00001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
beta
ML2$estimate
beta-ML2$estimate
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			for (j in sample(1:ndrugs)) {#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			}#
		#
			cat(beta, "\n")#
		#
			if (type == "laplace") { # laplace#
				cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
			} else {							# normal#
				cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
			}#
		#
			# calculate and check convergence criteria#
				conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
				conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
				if (as.numeric(conv	) <= 0.00001) { done = TRUE }				#
		}#
	)	# end system.time
				cat("log post:", l(ML2$estimate, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
					- (0.5/sigma2_beta)*sum(ML2$estimate^2), "\n\n")
l(beta, X.sM)
l(ML2$estimate, X.sM)
sample(5)
sample(1,5)
sample(5,1)
sample(5,1)
sample(5,1)
sample(5,1)
?sample
sample(1:5,1)
5 %% 5
# test BBR-like procedure for SCCS#
#
# functions ------------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
	#
# RUN -------------------------------------------------------------------------#
	# read in data#
		# from "small_ge" data set, with 30 drugs selected#
#		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
		# from "small_ge" data set, with 53 drugs selected#
		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_53drugs.txt"#
			#
		# from "small_osim" data, drugs 1-50 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
		#
		# from "small_osim" data, drugs 1-100 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-100drugs.txt"#
		#
		# from "small_osim" data, 12 drugs selected#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
#
# loop to do BBR-type procedure ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
		iter = 1#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			#for (j in sample(1:ndrugs, 1)) {#
			j = sample(1:ndrugs, 1)#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			#}#
			#
			iter = iter + 1#
		#
			if (iter %% ndrugs == 0) {#
				cat(beta, "\n")#
		#
				if (type == "laplace") { # laplace#
					cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
				} else {						# normal#
					cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
						- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
				}#
		#
				# calculate and check convergence criteria#
					conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
					conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
					if (as.numeric(conv	) <= 0.001) { done = TRUE }			}#
		}#
	)	# end system.time#
	#
	#
	#
# compare with ML procedures -----------------------------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.00001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
# test BBR-like procedure for SCCS#
#
# functions ------------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
	#
# RUN -------------------------------------------------------------------------#
	# read in data#
		# from "small_ge" data set, with 30 drugs selected#
#		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
		# from "small_ge" data set, with 53 drugs selected#
		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_53drugs.txt"#
			#
		# from "small_osim" data, drugs 1-50 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
		#
		# from "small_osim" data, drugs 1-100 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-100drugs.txt"#
		#
		# from "small_osim" data, 12 drugs selected#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
#
# loop to do BBR-type procedure ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
		iter = 1#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			#for (j in sample(1:ndrugs, 1)) {#
			j = sample(1:ndrugs, 1)#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			#}#
			#
			iter = iter + 1#
		#
			if (iter %% ndrugs == 0) {#
				cat(beta, "\n")#
		#
				if (type == "laplace") { # laplace#
					cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
				} else {						# normal#
					cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
						- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
				}#
		#
				# calculate and check convergence criteria#
					conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
					conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
					if (as.numeric(conv	) <= 0.00001) { done = TRUE }			}#
		}#
	)	# end system.time#
	#
	#
	#
# compare with ML procedures -----------------------------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.00001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
ML2$estimate
beta
abs(ML2$estimate) - abs(beta)
cbind(ML2$estimate, beta)
cbind(ML2$estimate, beta, beta-ML2$estimate)
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
beta
					cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
						- (0.5/sigma2_beta)*sum(beta^2), "\n\n")
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "normal"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
		iter = 1#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			#for (j in sample(1:ndrugs, 1)) {#
			j = sample(1:ndrugs, 1)#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			#}#
			#
			iter = iter + 1#
		#
			if (iter %% ndrugs == 0) {#
				cat(beta, "\n")#
		#
				if (type == "laplace") { # laplace#
					cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
				} else {						# normal#
					cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
						- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
				}#
		#
				# calculate and check convergence criteria#
					conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
					conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
					if (as.numeric(conv	) <= 0.00001) { done = TRUE }			}#
		}#
	)	# end system.time
abs(ML2$estimate)-abs(beta)
# test BBR-like procedure for SCCS#
#
# functions ------------------------------------------------------------------#
#
	# multivariate form for sccs likelihood, takes sparse matrix X as input#
	#	where X represents a matrix of size (total numpds x num drugs)#
	l = function(par, X) {#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
	#
		denom_pid = apply(PIDlist, 1, function(pid) { #
			sum(offs_exp_X_par[dat$PID == pid]) })#
	#
		loglik = as.numeric( (eta %*% X_par) - (n_pid %*% log(denom_pid)) )#
#
		return( loglik )#
	}#
	#
	#
	# calculate gradient of log likelihood#
	#		par = vector of parameters#
	#		X = SPARSE matrix of covariates (sum_i(r_i) x p dimensional)#
	#			where r_i = num of risk periods for person i #
	grad = function(par, X) {#
		#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
#
		scale_pid = apply(as.matrix(dat$PID), 1, #
			function(pid) {#
				index = which(PIDlist == pid);#
				return( n_pid[index] / denom_pid[index] )#
			} )#
#
		# holds the (n_i * pi_ik) terms#
		scale_pi_pid = scale_pid * offs_exp_X_par#
	#
		gradient = as.numeric(t(eta - scale_pi_pid) %*% X)#
	#
		return(gradient)#
	}#
#
#
	# fisher information where X is the sparse matrix of covariates (drugs), #
	# representing a matrix of dimension (total numpds x num drugs)#
	fisherinfo <- function(par, X) {#
		p = dim(X)[2]#
		eta = as.matrix(dat$EVT)#
		offs = dat$OFFS#
	#
		X_par = X %*% par	#
		exp_X_par = exp(X_par)#
		offs_exp_X_par = offs * exp_X_par#
#
		# number of events for each person#
		n_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) }))#
	#
		# denominator term for "pi" vector#
		denom_pid = as.matrix(apply(PIDlist, 1, function(pid) { sum(offs_exp_X_par[dat$PID == pid]) }))#
	#
		# for first term#
		x_offs_exp_X_par = as.matrix(apply(PIDlist, 1, function(pid) {#
				indices = which(dat$PID == pid)#
				return(#
					as.numeric(t(offs_exp_X_par[indices]) %*% X[indices,])#
				)#
			}))#
#
		# scale by denominator#
		x_offs_exp_X_par = t(x_offs_exp_X_par) / as.numeric(denom_pid) #
		x_offs_exp_X_par_outer = t(apply(x_offs_exp_X_par, 1, function(x) { x %o% x }))#
#
		X_outer = t(apply(X, 1, function(x) { x %o% x }))#
	#
		term2 = t(apply(PIDlist, 1, function(pid) { #
			t(offs_exp_X_par[dat$PID == pid]) %*% X_outer[dat$PID == pid,]#
		})) / as.numeric(denom_pid)#
#
		total = matrix(t(n_pid) %*% (x_offs_exp_X_par_outer - term2), nrow=p, ncol=p)#
#
		return(-total)#
	}#
#
#
	# BBR type update for parameter component beta_j#
	update_beta_j <- function(j, beta, X, type) {#
	#
			X_beta = as.numeric(X %*% beta)#
			exp_X_beta = exp(X_beta)#
			offs_exp_X_beta = offs * exp_X_beta#
			x_offs_exp_X_beta = X[,j] * offs_exp_X_beta#
		#
		# denominator term#
		denom_pid = apply(PIDlist, 1, function(pid) { sum(offs_exp_X_beta[dat$PID == pid]) })#
			#
		# numerator term#
		numer_pid = apply(PIDlist, 1, function(pid) { sum(x_offs_exp_X_beta[dat$PID == pid]) })#
			#
		# scale by denominator#
		t1 = numer_pid / denom_pid#
		#
		if (type == "normal") {		# normal prior#
			#
			g_d1 = (n_pid %*% t1) - (X[,j] %*% eta) + (beta[j]/sigma2_beta)#
			g_d2 = (n_pid %*% (t1 * (1-t1))) + (1/sigma2_beta)#
#
			update = -as.numeric(g_d1/g_d2)#
#
		} else {								# laplace prior#
			#
			g_d2 = n_pid %*% (t1 * (1-t1))#
			g_d1_first = (n_pid %*% t1) - (X[,j] %*% eta)#
#
			if ( sign(beta[j]) == 0 ) {#
				neg_update = -as.numeric((g_d1_first - lambda)/g_d2)#
				pos_update = -as.numeric((g_d1_first + lambda)/g_d2)#
				#
				# only one of these conditions will hold, from convexity#
					update = ifelse( neg_update < 0, neg_update,#
							ifelse( pos_update > 0, pos_update, 0) )#
							#
			} else {#
				update = -as.numeric((g_d1_first + lambda*sign(beta[j]))/g_d2)#
				#
				# update would change sign, so return beta_j to 0#
				if (sign(beta[j] + update) != sign(beta[j])) {#
					update = -beta[j]#
				}#
			}#
		}#
		#
		return( update )#
	}#
	#
	#
	#
# RUN -------------------------------------------------------------------------#
	# read in data#
		# from "small_ge" data set, with 30 drugs selected#
#		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_30drugs.txt"#
#
		# from "small_ge" data set, with 53 drugs selected#
		datafile = "/Users/ses/Desktop/sccs_multivar_package/sm_ge_format_multivar_OUT_53drugs.txt"#
			#
		# from "small_osim" data, drugs 1-50 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-50drugs.txt"#
		#
		# from "small_osim" data, drugs 1-100 (ndrugs = )#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_1-100drugs.txt"#
		#
		# from "small_osim" data, 12 drugs selected#
#		datafile = "/Users/ses/Desktop/format_multivar_OUT_12drugs.txt"#
		#
#
	# data in format of flat tab-delimited text file, header: #
	#	PID	EVT	OFFS	D1	D2	D3	... etc.#
	dat = read.table(datafile, fill=TRUE, row.names=NULL, #
				header=TRUE, sep="\t")        # will automatically pad with NAs#
												        # for rows w/o max num of drugs#
	nrows = dim(dat)[1]#
	ncols = dim(dat)[2]#
	drugcols = paste("D", 1:(ncols-3), sep="")#
#
	dat$PID = as.numeric(dat$PID)#
		#
	# vector containing all (unique) drug id numbers#
		druglist = unique(as.numeric(as.matrix(dat[drugcols])))#
		druglist = druglist[!is.na(druglist)]#
		druglist = druglist[druglist != 0]#
		druglist = sort(druglist)#
		ndrugs = length(druglist)#
#
		# unique PIDS#
		PIDlist = as.matrix(unique(dat$PID))#
#
		# sparseMatrix: covariate matrix, in sparse format (in "Matrix" package)#
			require(Matrix)#
			i = NULL#
			j = NULL#
			for (d in 1:ndrugs) {#
				this_row = which(dat[drugcols] == druglist[d], arr.ind=TRUE)[,1]#
				i = c(i, this_row)#
				j = c(j, rep(d, length(this_row)))#
			}#
			X.sM = sparseMatrix(i=i, j=j, dims=c(nrows, ndrugs))#
#
			X.sM = as(X.sM, "dgCMatrix")#
	#
	eta = dat$EVT#
	offs = dat$OFFS#
		#
	# number of events for each person#
	n_pid = apply(PIDlist, 1, function(pid) { sum(eta[dat$PID == pid]) })#
#
#
#
# loop to do BBR-type procedure ---------------------------------------------------#
#
	# set prior parameters#
		sigma2_beta = 1000#
		lambda = sqrt(2/200)#
	#
	# other initializations#
		type = "laplace"#
		done = FALSE#
		beta = numeric(ndrugs)#
		delta = rep(5, ndrugs)#
		iter = 1#
#
	system.time(#
		while(!done) {#
			beta_old = beta#
		#
			#for (j in sample(1:ndrugs, 1)) {#
			j = sample(1:ndrugs, 1)#
				update = update_beta_j(j, beta, X.sM, type)#
			#
				update = ifelse(update < -delta[j], -delta[j], #
							ifelse(update > delta[j], delta[j], update))#
			#
				delta[j] = max(2*abs(update), 0.5*delta[j])#
			#
				beta[j] = beta[j] + update#
			#}#
			#
			iter = iter + 1#
		#
			if (iter %% ndrugs == 0) {#
				cat(beta, "\n")#
		#
				if (type == "laplace") { # laplace#
					cat("log post:", l(beta, X.sM) + ndrugs*log(0.5*lambda) - lambda*sum(abs(beta)), "\n\n")#
				#
				} else {						# normal#
					cat("log post:", l(beta, X.sM) - 0.5*ndrugs*log(2*pi*sigma2_beta) #
						- (0.5/sigma2_beta)*sum(beta^2), "\n\n")#
				}#
		#
				# calculate and check convergence criteria#
					conv = t(abs(X.sM %*% (beta - beta_old))) %*% eta#
					conv = conv / (1 + (t(abs(X.sM %*% beta_old)) %*% eta) )#
		#
					if (as.numeric(conv	) <= 0.00001) { done = TRUE }			}#
		}#
	)	# end system.time#
	#
	#
	#
# compare with ML procedures -----------------------------------------------------#
	require(maxLik)#
	#
	# set tolerance level#
	tol = 0.00001#
	#
	# directly#
#	ML1 = maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
	#
#	system.time(#
#		maxLik(function(beta) { l(beta, X.sM) }, start = numeric(ndrugs), tol=tol)#
#	)#
	#
	# with gradient, hessian (faster)#
	ML2 = maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
				#
	system.time(#
		maxLik(function(beta) { l(beta, X.sM) }, #
				grad = function(beta) { grad(beta, X.sM) }, #
				hess = function(beta) { -fisherinfo(beta, X.sM) },#
				start = numeric(ndrugs),#
				tol = tol)#
	)
beta
abs(ML2$estimate) - abs(beta)
